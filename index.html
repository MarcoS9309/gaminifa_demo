<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Artery Dash</title>
  <style>
    /* --- Reset mínimo y layout --- */
    html, body { height: 100%; margin: 0; background: linear-gradient(135deg, #0a0a0a, #1a0515); }
    body { display: grid; place-items: center; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    .frame { 
      position: relative; 
      width: min(96vw, 540px); 
      aspect-ratio: 9/16; 
      box-shadow: 0 20px 60px rgba(0,0,0,.7), inset 0 1px 0 rgba(255,255,255,.1); 
      border-radius: 20px; 
      overflow: hidden; 
      background: #1a0f1a;
      border: 2px solid rgba(255, 155, 192, 0.3);
    }
    canvas { 
      width: 100%; 
      height: 100%; 
      image-rendering: pixelated; 
      image-rendering: crisp-edges;
      display: block; 
    }
    .hud { 
      position: absolute; 
      inset: 0; 
      pointer-events: none; 
      color: #ffe9f6; 
      text-shadow: 0 2px 4px rgba(122, 31, 90, 0.8), 0 0 10px rgba(255, 155, 192, 0.3); 
    }
    .hud .row { 
      display: flex; 
      justify-content: space-between; 
      padding: .8rem 1rem; 
      font-weight: 700; 
      font-size: 1rem;
    }
    .btns { 
      position: absolute; 
      left: 50%; 
      bottom: 1.2rem; 
      translate: -50% 0; 
      display: flex; 
      gap: .6rem; 
      pointer-events: auto; 
    }
    button { 
      background: linear-gradient(135deg, #ff3d82, #e6306f);
      color: #fff; 
      border: none; 
      padding: .8rem 1.1rem; 
      border-radius: 12px; 
      font-weight: 700; 
      cursor: pointer; 
      box-shadow: 0 8px 0 #7a1f5a, 0 8px 20px rgba(255, 61, 130, 0.3); 
      transition: all .1s ease; 
      font-size: 0.9rem;
    }
    button:hover {
      background: linear-gradient(135deg, #ff5599, #e6306f);
      transform: translateY(-2px);
      box-shadow: 0 10px 0 #7a1f5a, 0 10px 25px rgba(255, 61, 130, 0.4);
    }
    button:active { 
      transform: translateY(4px); 
      box-shadow: 0 4px 0 #7a1f5a, 0 4px 15px rgba(255, 61, 130, 0.3); 
    }
    .mute { 
      background: linear-gradient(135deg, #7a1f5a, #5c1742);
    }
    .mute:hover {
      background: linear-gradient(135deg, #8b2465, #5c1742);
    }
    .toast { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      translate: -50% -50%; 
      background: rgba(42, 15, 40, 0.95);
      backdrop-filter: blur(10px);
      border: 2px solid #ff9bc0; 
      color: #ffe9f6; 
      padding: 1.5rem 1.5rem; 
      border-radius: 16px; 
      max-width: 85%; 
      text-align: center; 
      pointer-events: auto;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
    }
    .toast h2 { 
      margin: .2rem 0 .6rem; 
      font-size: 1.3rem; 
      text-shadow: 0 0 10px rgba(255, 155, 192, 0.5);
    }
    .toast p { 
      margin: .4rem 0 .8rem; 
      line-height: 1.4;
    }
    .kbd { 
      background: #35142f; 
      border: 1px solid #ff9bc0; 
      padding: .1rem .4rem; 
      border-radius: 6px; 
      font-weight: 800; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .credits { 
      position: absolute; 
      bottom: .4rem; 
      right: .8rem; 
      font-size: .7rem; 
      opacity: .8; 
    }
  </style>
</head>
<body>
  <div class="frame" id="frame">
    <canvas id="game" width="360" height="640" aria-label="Artery Dash - videojuego didáctico"></canvas>
    <div class="hud" aria-hidden="true">
      <div class="row">
        <div>Puntuación: <span id="score">0</span></div>
        <div>Récord: <span id="best">0</span></div>
      </div>
      <div class="credits">Artery Dash · © 2025</div>
    </div>
    <div class="btns">
      <button id="tap">Saltar (␣)</button>
      <button id="pause">Pausa (P)</button>
      <button id="mute" class="mute">Sonido</button>
    </div>
    <div id="overlay" class="toast" style="display:none"></div>
  </div>

  <script>
  /*
   * Artery Dash Enhanced Edition - Educational Flappy Bird-style Game
   * Copyright (c) 2025 Marco Vinicio (MarcoS9309)
   * 
   * A pixel art medical-themed game set inside a blood vessel.
   * Control a red blood cell navigating through arteries while avoiding
   * cholesterol plaques, white blood cells, and bacteria.
   * 
   * Features:
   * - Advanced particle system
   * - Optimized rendering with cached gradients
   * - Smooth animations and visual effects
   * - Educational medical content
   * 
   * License: MIT (see LICENSE file)
   * Repository: https://github.com/MarcoS9309/Arltery_dash-demo
   */
  (function(){
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    const overlay = document.getElementById('overlay');
    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    const btnTap  = document.getElementById('tap');
    const btnPause= document.getElementById('pause');
    const btnMute = document.getElementById('mute');

    // Escala base en "píxeles gordos" para estética pixel art
    const PX = 2; // modificar a 3/4 para pixels más grandes

    // Estado global
    let state = 'menu'; // 'menu' | 'play' | 'crash'
    let t0 = performance.now();
    let acc = 0; // acumulador para dt fijo
    const fixedDt = 1000/60; // 60 FPS
    let score = 0;
    let best = Number(localStorage.getItem('artery-best')||0);
    bestEl.textContent = best;

    // Cache de gradientes para optimización
    let bgGradient, arteryGradient;
    let particleSystem = [];
    
    // Performance monitoring
    let frameCount = 0;
    let lastFpsUpdate = 0;
    let currentFps = 60;

    // Inicializar gradientes una sola vez
    function initGradients() {
      bgGradient = ctx.createLinearGradient(0,0,0,world.h);
      bgGradient.addColorStop(0, '#3b0b2e');
      bgGradient.addColorStop(0.5, '#4d0e3d');
      bgGradient.addColorStop(1, '#300a24');
      
      arteryGradient = ctx.createLinearGradient(0,0,0,world.h);
      arteryGradient.addColorStop(0, '#8b1e5a');
      arteryGradient.addColorStop(0.5, '#a0275f');
      arteryGradient.addColorStop(1, '#8b1e5a');
    }
    
    // Monitor FPS for performance optimization
    function updateFPS(timestamp) {
      frameCount++;
      if (timestamp - lastFpsUpdate >= 1000) {
        currentFps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = timestamp;
        
        // Adjust particle system based on performance
        if (currentFps < 45 && particleSystem.length > 50) {
          particleSystem.splice(0, Math.floor(particleSystem.length * 0.3));
        }
      }
    }

    let muted = false; 
    let paused = false;

    // Mundo
    const world = {
      w: cvs.width,
      h: cvs.height,
      speed: 1.6, // velocidad horizontal base
      gravity: 0.35,
      jump: -6.2,
      arteryPhase: 0,
    };

    // Jugador: glóbulo rojo (GR)
    const player = {
      x: 80,
      y: cvs.height/2,
      vy: 0,
      r: 10*PX, // radio visual aproximado
      alive: true,
      spin: 0,
    };

    // Obstáculos tipo "placas" (par superior/inferior con hueco)
    const plaques = [];
    // Otros obstáculos sueltos
    const hazards = []; // leucocitos y bacterias
    // Bonus
    const bonuses = [];

    // Timers de spawn
    let timeToPlaque = 0;
    let timeToHazard = 120; // frames
    let timeToBonus  = 90;  // frames

    // Utilidades
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand  = (a, b) => a + Math.random()*(b-a);
    const chance= p => Math.random() < p;

    // Audio simple (WebAudio - bips básicos generados por oscilador)
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioCtx();
    function beep(freq=440, time=0.06, type='square', gain=0.03){
      if(muted) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain; o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + time);
    }

    // Dibujo: fondo de arteria (paredes pulsátiles) - OPTIMIZADO
    function drawBackground(){
      // Usar gradiente cacheado
      ctx.fillStyle = bgGradient; 
      ctx.fillRect(0,0,world.w,world.h);

      // Paredes y endotelio con sinusoide mejorada
      world.arteryPhase += 0.02;
      ctx.fillStyle = arteryGradient;
      const amp = 8*PX;
      const yTop = 60 + Math.sin(world.arteryPhase)*amp;
      const yBot = world.h - 60 + Math.cos(world.arteryPhase*0.9)*amp;
      
      // Paredes con gradiente
      ctx.fillRect(0,0,world.w,yTop);
      ctx.fillRect(0,yBot,world.w,world.h-yBot);

      // Detalle: estrías con patrón más suave
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#ff9bc0';
      for(let x=0; x<world.w; x+= 20*PX){
        const striaHeight = world.h - yTop - (world.h - yBot);
        ctx.fillRect(x, yTop, 3, striaHeight);
        ctx.fillRect(x+10*PX, yTop, 1, striaHeight);
      }
      
      // Añadir puntos de luz flotantes
      ctx.globalAlpha = 0.15;
      for(let i=0; i<8; i++){
        const x = (world.arteryPhase*30 + i*45) % world.w;
        const y = yTop + 40 + Math.sin(world.arteryPhase + i)*20;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Dibujo: glóbulo rojo (disco biconcavo estilizado pixel) - MEJORADO
    function drawPlayer(p){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spin);
      
      // Sombra sutil
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#2a0f28';
      roundedRect(-p.r+2, -p.r*0.6+2, p.r*2, p.r*1.2, 6);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Gradiente para el glóbulo
      const playerGradient = ctx.createRadialGradient(-p.r*0.3, -p.r*0.3, 0, 0, 0, p.r*1.2);
      playerGradient.addColorStop(0, '#ff5577');
      playerGradient.addColorStop(0.7, '#e43f5a');
      playerGradient.addColorStop(1, '#bb2c49');
      
      // aro externo con gradiente
      ctx.fillStyle = playerGradient;
      roundedRect(-p.r, -p.r*0.6, p.r*2, p.r*1.2, 6);
      ctx.fill();
      
      // centro más oscuro con brillo
      ctx.fillStyle = '#aa1f3d';
      roundedRect(-p.r*0.6, -p.r*0.36, p.r*1.2, p.r*0.72, 5);
      ctx.fill();
      
      // Punto de brillo
      ctx.fillStyle = '#ff8899';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(-p.r*0.4, -p.r*0.2, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      ctx.restore();
    }

    function roundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.lineTo(x+w-r, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+r);
      ctx.lineTo(x+w, y+h-r);
      ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      ctx.lineTo(x+r, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-r);
      ctx.lineTo(x, y+r);
      ctx.quadraticCurveTo(x, y, x+r, y);
      ctx.closePath();
    }

    // Sistema de partículas mejorado
    function createParticle(x, y, type) {
      return {
        x, y,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 60,
        maxLife: 60,
        type, // 'bonus', 'collision', 'trail'
        color: type === 'bonus' ? '#74d0ff' : type === 'collision' ? '#ff3d82' : '#ffaa66'
      };
    }

    function updateParticles() {
      // Optimización: Limitar número máximo de partículas
      const maxParticles = currentFps > 50 ? 150 : 75;
      
      for(let i = particleSystem.length - 1; i >= 0; i--) {
        const p = particleSystem[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vy += 0.1; // gravedad ligera
        
        if(p.life <= 0) {
          particleSystem.splice(i, 1);
        }
      }
      
      // Eliminar partículas excesivas si es necesario
      if(particleSystem.length > maxParticles) {
        particleSystem.splice(0, particleSystem.length - maxParticles);
      }
    }

    function drawParticles() {
      for(const p of particleSystem) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2 * alpha + 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Dibujo: placas (pareja superior/inferior) - MEJORADO
    function drawPlaque(pl){
      // Gradiente para las placas
      const plaqueGradient = ctx.createLinearGradient(pl.x, 0, pl.x + pl.w, 0);
      plaqueGradient.addColorStop(0, '#d6b35c');
      plaqueGradient.addColorStop(0.5, '#f4d478');
      plaqueGradient.addColorStop(1, '#c49a4a');
      
      ctx.fillStyle = plaqueGradient;
      
      // superior
      ctx.fillRect(pl.x, 0, pl.w, pl.gapY - pl.gap/2);
      // inferior
      ctx.fillRect(pl.x, pl.gapY + pl.gap/2, pl.w, world.h - (pl.gapY + pl.gap/2));

      // textura granulada mejorada
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#b8923d';
      for(let y=0; y<world.h; y+= 8){
        for(let x=0; x<pl.w; x+= 8){
          if(Math.random() > 0.7) {
            ctx.fillRect(pl.x + x, y, 2, 2);
          }
        }
      }
      
      // Bordes con sombra
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = '#8b7239';
      ctx.fillRect(pl.x + pl.w - 2, 0, 2, pl.gapY - pl.gap/2);
      ctx.fillRect(pl.x + pl.w - 2, pl.gapY + pl.gap/2, 2, world.h - (pl.gapY + pl.gap/2));
      
      ctx.globalAlpha = 1;
    }

    // Dibujo: leucocito (círculo blanco con núcleo) - MEJORADO
    function drawLeukocyte(h){
      ctx.save();
      ctx.translate(h.x, h.y);
      
      // Sombra
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#2a0f28';
      ctx.beginPath(); 
      ctx.arc(2, 2, h.r, 0, Math.PI*2); 
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Gradiente del leucocito
      const wbcGradient = ctx.createRadialGradient(-h.r*0.3, -h.r*0.3, 0, 0, 0, h.r);
      wbcGradient.addColorStop(0, '#ffffff');
      wbcGradient.addColorStop(0.8, '#f0f0f0');
      wbcGradient.addColorStop(1, '#d0d0d0');
      
      ctx.fillStyle = wbcGradient;
      ctx.beginPath(); ctx.arc(0,0,h.r,0,Math.PI*2); ctx.fill();
      
      // Núcleo con gradiente
      const nucleusGradient = ctx.createRadialGradient(-h.r*0.1, -h.r*0.1, 0, 0, 0, h.r*0.6);
      nucleusGradient.addColorStop(0, '#e6edff');
      nucleusGradient.addColorStop(1, '#cbd3ff');
      
      ctx.fillStyle = nucleusGradient;
      ctx.beginPath(); ctx.arc(-h.r*0.2,0,h.r*0.55,0,Math.PI*2); ctx.fill();
      
      // Brillo
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(-h.r*0.4, -h.r*0.4, h.r*0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      ctx.restore();
    }

    // Dibujo: bacteria (bastón con cilios) - MEJORADO
    function drawBacteria(h){
      ctx.save();
      ctx.translate(h.x, h.y); ctx.rotate(h.a);
      
      // Sombra
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#2a0f28';
      roundedRect(-h.len/2+1, -h.th/2+1, h.len, h.th, 4);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Gradiente de la bacteria
      const bacGradient = ctx.createLinearGradient(0, -h.th/2, 0, h.th/2);
      bacGradient.addColorStop(0, '#66ff99');
      bacGradient.addColorStop(0.5, '#4ee07d');
      bacGradient.addColorStop(1, '#33cc66');
      
      ctx.fillStyle = bacGradient;
      roundedRect(-h.len/2, -h.th/2, h.len, h.th, 4);
      ctx.fill();
      
      // Línea central
      ctx.fillStyle = '#2d8f4f';
      ctx.fillRect(-h.len/2, -1, h.len, 2);
      
      // cilios mejorados
      ctx.strokeStyle = '#4ee07d'; 
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      for(let i=-h.len/2; i<h.len/2; i+= 6){
        const waveOffset = Math.sin(Date.now() * 0.01 + i * 0.2) * 2;
        ctx.beginPath();
        ctx.moveTo(i, -h.th/2);
        ctx.lineTo(i + waveOffset, -h.th/2 - 8);
        ctx.moveTo(i, h.th/2);
        ctx.lineTo(i + waveOffset, h.th/2 + 8);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Dibujo: bonus (oxígeno y vitamina) - MEJORADO
    function drawBonus(b){
      const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.1; // pulsación suave
      
      if(b.kind === 'O2'){
        ctx.save(); 
        ctx.translate(b.x, b.y);
        ctx.scale(pulseScale, pulseScale);
        
        // Resplandor
        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, b.r * 2);
        glowGradient.addColorStop(0, 'rgba(116, 208, 255, 0.4)');
        glowGradient.addColorStop(1, 'rgba(116, 208, 255, 0)');
        ctx.fillStyle = glowGradient;
        ctx.beginPath(); ctx.arc(0,0, b.r * 2, 0, Math.PI*2); ctx.fill();
        
        // Gradiente del bonus
        const o2Gradient = ctx.createRadialGradient(-b.r*0.3, -b.r*0.3, 0, 0, 0, b.r);
        o2Gradient.addColorStop(0, '#a8e6ff');
        o2Gradient.addColorStop(0.7, '#74d0ff');
        o2Gradient.addColorStop(1, '#4db8ff');
        
        ctx.fillStyle = o2Gradient;
        ctx.beginPath(); ctx.arc(0,0, b.r, 0, Math.PI*2); ctx.fill();
        
        // Texto con sombra
        ctx.fillStyle = '#003366';
        ctx.font = 'bold 12px monospace'; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.fillText('O₂', 1, 1);
        
        ctx.fillStyle = '#ffffff'; 
        ctx.fillText('O₂', 0, 0);
        ctx.restore();
      } else {
        ctx.save(); 
        ctx.translate(b.x, b.y);
        ctx.scale(pulseScale, pulseScale);
        
        // Resplandor
        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, b.r * 2);
        glowGradient.addColorStop(0, 'rgba(255, 204, 0, 0.4)');
        glowGradient.addColorStop(1, 'rgba(255, 204, 0, 0)');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(-b.r*2, -b.r*2.4, b.r*4, b.r*4.8);
        
        // Gradiente de la vitamina
        const vitGradient = ctx.createLinearGradient(0, -b.r*1.2, 0, b.r*1.2);
        vitGradient.addColorStop(0, '#ffdd44');
        vitGradient.addColorStop(0.5, '#ffcc00');
        vitGradient.addColorStop(1, '#cc9900');
        
        ctx.fillStyle = vitGradient;
        roundedRect(-b.r, -b.r*1.2, b.r*2, b.r*2.4, 6);
        ctx.fill();
        
        // Etiqueta mejorada
        ctx.fillStyle = '#4d2600'; 
        ctx.fillRect(-3, -b.r*1.2, 6, b.r*2.4);
        
        // Brillo
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.3;
        ctx.fillRect(-b.r*0.8, -b.r*1.0, b.r*1.6, b.r*0.4);
        ctx.globalAlpha = 1;
        
        ctx.restore();
      }
    }

    // Generadores
    function spawnPlaque(){
      const w = 40*PX;
      const gap = clamp(110 + (200 - Math.min(score*2, 160)), 90, 200); // gap dinámico con dificultad
      const gapY = rand(150, world.h-150);
      plaques.push({ x: world.w+10, w, gap, gapY, passed:false });
    }

    function spawnHazard(){
      if(chance(0.6)){
        // leucocito
        hazards.push({ type:'wbc', x: world.w+10, y: rand(80, world.h-80), r: rand(10*PX, 16*PX), vx: -(world.speed*0.8 + rand(0.5,1.2)), vy: rand(-0.3,0.3) });
      } else {
        // bacteria
        hazards.push({ type:'bac', x: world.w+10, y: rand(80, world.h-80), len: rand(30, 50), th: rand(10, 16), a: rand(0,Math.PI), va: rand(-0.05,0.05), vx: -(world.speed + rand(0.6,1.6)) });
      }
    }

    function spawnBonus(){
      const kind = chance(0.5) ? 'O2' : 'VIT';
      bonuses.push({ kind, x: world.w+10, y: rand(80, world.h-80), r: 10, vx: - (world.speed + 0.8) });
    }

    // Físicas básicas y colisiones
    function circleRectCollision(cx, cy, cr, rx, ry, rw, rh){
      // distancia punto-rect con clamp
      const nx = clamp(cx, rx, rx+rw);
      const ny = clamp(cy, ry, ry+rh);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx + dy*dy) <= (cr*cr);
    }

    function circleCircleCollision(a, b){
      const dx = a.x-b.x, dy = a.y-b.y; const r = (a.r||a.th/2) + (b.r||b.th/2);
      return dx*dx + dy*dy <= r*r;
    }

    // UI overlays
    function showMenu(){
      overlay.style.display = 'block';
      overlay.innerHTML = `
        <h2>Artery Dash</h2>
        <p>Controla un <strong>glóbulo rojo</strong> por la arteria esquivando placas, leucocitos, bacterias y coágulos.<br>
        Toma <strong>oxígeno</strong> y <strong>vitaminas</strong> para sumar puntos extra.</p>
        <p><span class="kbd">␣</span> / click / toque: <strong>Saltar</strong> · <span class="kbd">P</span>: Pausa · <span class="kbd">M</span>: Sonido</p>
        <button id="start">Jugar</button>
      `;
      overlay.querySelector('#start').onclick = startGame;
    }

    function showDoctor(){
      const dx = pickDiagnosis();
      overlay.style.display = 'block';
      overlay.innerHTML = `
        <h2>Pixel-Doctor</h2>
        <p><em>${dx.title}</em></p>
        <p>${dx.msg}</p>
        <button id="retry">Reintentar (R)</button>
      `;
      overlay.querySelector('#retry').onclick = resetAndGo;
    }

    function pickDiagnosis(){
      const msgs = [
        {t:'Hipoxia aguda', m:'Prescribo: 3 toques de barra espaciadora cada 8 segundos. Evite placas a la vista.'},
        {t:'Aterotetris crónica', m:'Demasiados bloques amarillos. Recomendación: dieta baja en píxeles saturados.'},
        {t:'Globulitis distraída', m:'Síntoma: mirar el marcador. Tratamiento: mirar el hueco.'},
        {t:'Leucocito celoso', m:'El guardia blanco te hizo la cama. Solución: celeridad y elegancia.'},
        {t:'Bacteriosis memética', m:'Esa bacteria venía con chiste. Risa, pero menos choque.'},
        {t:'Coagulitis express', m:'Si se coagula, se salta. Protocolo aprobado por el pixel-COE.'},
      ];
      const it = msgs[Math.floor(Math.random()*msgs.length)];
      return { title: it.t, msg: it.m };
    }

    // Control del juego
    function startGame(){
      overlay.style.display = 'none';
      reset();
      state = 'play';
      beep(660, .05, 'square', .02);
    }

    function reset(){
      score = 0; scoreEl.textContent = score;
      player.x = 80; player.y = cvs.height/2; player.vy = 0; player.alive = true; player.spin = 0;
      plaques.length = 0; hazards.length = 0; bonuses.length = 0;
      timeToPlaque = 0; timeToHazard = 90; timeToBonus = 60;
    }

    function gameOver(){
      state = 'crash';
      best = Math.max(best, score); localStorage.setItem('artery-best', best); bestEl.textContent = best;
      beep(180,.12,'sawtooth',.03);
      setTimeout(showDoctor, 180);
    }

    function resetAndGo(){ reset(); state='play'; overlay.style.display='none'; }

    // Entrada de usuario
    function flap(){ if(state==='play'){ player.vy = world.jump; player.spin = -0.3; beep(880,.05,'square',.02);} }

    function togglePause(){ if(state==='play'){ paused = !paused; if(!paused){ t0 = performance.now(); acc=0; loop(); } } }
    function toggleMute(){ muted = !muted; btnMute.textContent = muted? 'Silencio ✓' : 'Sonido'; }

    // Eventos
    document.addEventListener('keydown', e => {
      if(e.code==='Space'){ e.preventDefault(); flap(); }
      if(e.code==='KeyP'){ togglePause(); }
      if(e.code==='KeyM'){ toggleMute(); }
      if(e.code==='KeyR' && state==='crash'){ resetAndGo(); }
      if(e.code==='Enter' && state==='menu'){ startGame(); }
    });
    btnTap.addEventListener('click', flap);
    btnPause.addEventListener('click', togglePause);
    btnMute.addEventListener('click', toggleMute);
    // Soporte táctil
    document.getElementById('frame').addEventListener('touchstart', (e)=>{ if(state==='menu'){ startGame(); } else { flap(); } }, {passive:true});

    // Bucle principal: dt fijo para consistencia + monitoreo de FPS
    function loop(now){
      if(state==='menu'){ drawBackground(); drawPlayer(player); return; }
      if(paused){ drawBackground(); drawScene(); drawPaused(); return; }
      
      now = now || performance.now();
      updateFPS(now); // Monitor performance
      
      acc += now - t0; t0 = now;
      while(acc >= fixedDt){ update(); acc -= fixedDt; }
      drawBackground(); drawScene();
      requestAnimationFrame(loop);
    }

    function update(){
      if(state!=='play') return;
      
      // física del jugador con interpolación suave
      player.vy += world.gravity; 
      player.vy = clamp(player.vy, -10, 10); 
      player.y += player.vy; 
      player.spin += 0.04; // reducido para suavidad
      player.spin = clamp(player.spin, -0.3, 0.6);

      // Agregar estela del jugador
      if(Math.random() < 0.3) {
        particleSystem.push(createParticle(
          player.x - player.r, 
          player.y + (Math.random() - 0.5) * player.r, 
          'trail'
        ));
      }

      // límites superior/inferior (pared arterial)
      if(player.y - player.r < 60 || player.y + player.r > world.h - 60){ 
        // Partículas de colisión
        for(let i = 0; i < 8; i++) {
          particleSystem.push(createParticle(player.x, player.y, 'collision'));
        }
        return gameOver(); 
      }

      // Actualizar partículas
      updateParticles();

      // spawn lógica
      if(timeToPlaque <= 0){ spawnPlaque(); timeToPlaque = 90; }
      timeToPlaque--;
      if(timeToHazard-- <= 0){ spawnHazard(); timeToHazard = Math.floor(rand(90, 160)); }
      if(timeToBonus-- <= 0){ spawnBonus(); timeToBonus = Math.floor(rand(80, 140)); }

      // mover y colisiones placas
      for(let i=plaques.length-1; i>=0; i--){
        const pl = plaques[i]; pl.x -= world.speed*2.2;
        // pasar hueco = +1 punto
        if(!pl.passed && pl.x + pl.w < player.x - player.r){ 
          pl.passed = true; score++; scoreEl.textContent = score; 
          beep(520,.05,'square',.02); 
          // Partículas de celebración
          for(let j = 0; j < 3; j++) {
            particleSystem.push(createParticle(player.x, player.y, 'bonus'));
          }
        }
        // colisión con bordes de placa
        if(circleRectCollision(player.x, player.y, player.r, pl.x, 0, pl.w, pl.gapY - pl.gap/2) ||
           circleRectCollision(player.x, player.y, player.r, pl.x, pl.gapY + pl.gap/2, pl.w, world.h - (pl.gapY + pl.gap/2))){
          // Partículas de colisión
          for(let j = 0; j < 12; j++) {
            particleSystem.push(createParticle(player.x, player.y, 'collision'));
          }
          return gameOver();
        }
        if(pl.x + pl.w < -20){ plaques.splice(i,1); }
      }

      // mover y colisiones hazards
      for(let i=hazards.length-1; i>=0; i--){
        const h = hazards[i]; h.x += h.vx; h.y += (h.vy||0); if(h.va) h.a += h.va;
        const shape = (h.type==='wbc')? {x:h.x,y:h.y,r:h.r} : {x:h.x,y:h.y,th:h.th};
        if(circleCircleCollision({x:player.x,y:player.y,r:player.r}, shape)) {
          // Partículas de colisión
          for(let j = 0; j < 10; j++) {
            particleSystem.push(createParticle(h.x, h.y, 'collision'));
          }
          return gameOver();
        }
        if(h.x < -60) hazards.splice(i,1);
      }

      // mover y colisiones bonus
      for(let i=bonuses.length-1; i>=0; i--){
        const b = bonuses[i]; b.x += b.vx;
        if(circleCircleCollision({x:player.x,y:player.y,r:player.r}, b)){
          score += (b.kind==='O2')? 2 : 3; scoreEl.textContent = score; 
          beep((b.kind==='O2')?780:920, .06, 'triangle', .025);
          // Partículas de recolección
          for(let j = 0; j < 6; j++) {
            particleSystem.push(createParticle(b.x, b.y, 'bonus'));
          }
          bonuses.splice(i,1); continue;
        }
        if(b.x < -40) bonuses.splice(i,1);
      }
    }

    function drawScene(){
      // dibujar objetos
      for(const pl of plaques) drawPlaque(pl);
      for(const h of hazards) (h.type==='wbc'? drawLeukocyte : drawBacteria)(h);
      for(const b of bonuses) drawBonus(b);
      
      // Dibujar partículas antes del jugador para que aparezcan detrás
      drawParticles();
      
      drawPlayer(player);
    }

    function drawPaused(){
      ctx.save(); ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,0,world.w,world.h);
      ctx.fillStyle='#ffe9f6'; ctx.font='bold 20px monospace'; ctx.textAlign='center';
      ctx.fillText('PAUSA', world.w/2, world.h/2);
      ctx.restore();
    }

    // Inicializar
    initGradients(); // Inicializar gradientes cacheados
    showMenu();
    drawBackground(); drawPlayer(player);
    requestAnimationFrame(loop);

  })();
  </script>
</body>
</html>
